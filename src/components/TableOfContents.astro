---
interface Heading {
  id: string;
  text: string;
  level: number;
  displayText: string;
}

interface Props {
  content?: string;
}

const { content = "" } = Astro.props;

function extractHeadings(content: string): Heading[] {
  const headings: Heading[] = [];
  const segments = content.split(/```[\s\S]*?```|~~~[\s\S]*?~~~/g);
  const idCounts = new Map<string, number>();

  segments.forEach((segment) => {
    const headingRegex = /^(#{1,6})\s+(.+)$/gm;
    let match;

    while ((match = headingRegex.exec(segment)) !== null) {
      const level = match[1].length;
      // Skip headings deeper than h3
      if (level > 3) continue;
      const text = match[2].trim();

      let baseId = text
        .toLowerCase()
        .replace(/[^\w\s-]/g, "")
        .replace(/\s+/g, "-")
        .trim();

      let id = baseId;
      const count = idCounts.get(baseId) || 0;
      if (count > 0) {
        id = `${baseId}-${count}`;
      }
      idCounts.set(baseId, count + 1);

      const displayIndex = count + 1;
      const displayText = displayIndex > 1 ? `${text} (${displayIndex})` : text;

      headings.push({ id, text, level, displayText });
    }
  });

  return headings;
}

const headings = extractHeadings(content);
---

{
  headings.length > 0 && (
    <div class="toc-container">
      <h3 class="toc-title mb-1.5 text-lg font-semibold">Table of Contents</h3>
      <nav class="toc-nav">
        <ul class="toc-list space-y-2">
          {headings.map((heading) => (
            <li class={`toc-item toc-level-${heading.level}`}>
              <a
                href={`#${heading.id}`}
                class="toc-link text-muted-text dark:text-dark-muted-text hover:text-link dark:hover:text-dark-link block text-sm transition-colors duration-200"
                style={`padding-left: ${(heading.level - 1) * 0.75}rem`}>
                {heading.displayText}
              </a>
            </li>
          ))}
        </ul>
      </nav>
    </div>
  )
}

<script>
  declare global {
    interface Window {
      tocObserver?: IntersectionObserver;
      tocCleanup?: () => void;
    }
  }

  function initTableOfContents() {
    const prose = document.querySelector(".prose");
    if (!prose) return;

    // Generate IDs/anchors for all headings
    const allHeadings = prose.querySelectorAll("h1, h2, h3, h4, h5, h6");
    const idCounts = new Map<string, number>();

    allHeadings.forEach((heading) => {
      if (!heading.id) {
        const text = heading.textContent || "";
        let baseId = text
          .toLowerCase()
          .replace(/[^\w\s-]/g, "")
          .replace(/\s+/g, "-")
          .trim();

        let id = baseId;
        const count = idCounts.get(baseId) || 0;
        if (count > 0) {
          id = `${baseId}-${count}`;
        }
        idCounts.set(baseId, count + 1);

        heading.id = id;
      }

      if (!heading.querySelector(".heading-link")) {
        const anchor = document.createElement("a");
        anchor.className = "heading-link";
        anchor.href = `#${heading.id}`;
        anchor.setAttribute("aria-label", "Link to this section");
        anchor.textContent = "#";

        anchor.addEventListener("click", (e) => {
          e.preventDefault();
          const url = new URL(window.location.href);
          url.hash = heading.id;
          navigator.clipboard
            .writeText(url.toString())
            .then(() => {
              window.location.hash = heading.id;
            })
            .catch(console.error);
        });

        heading.appendChild(anchor);
      }
    });

    if (window.tocObserver) {
      window.tocObserver.disconnect();
      window.tocObserver = undefined;
    }
    if (window.tocCleanup) {
      window.tocCleanup();
      window.tocCleanup = undefined;
    }

    const tocLinks = Array.from(document.querySelectorAll<HTMLAnchorElement>(".toc-link"));
    // Only track up to h3 for TOC active state and scrolling
    const headingEls = Array.from(prose.querySelectorAll<HTMLHeadingElement>("h1, h2, h3")).filter(
      (h) => !!h.id,
    );

    const linksById = new Map<string, HTMLAnchorElement>();
    tocLinks.forEach((a) => {
      const id = decodeURIComponent((a.getAttribute("href") || "").replace(/^#/, ""));
      if (id) linksById.set(id, a);
    });

    function setActive(id?: string) {
      if (!id) return;
      const link = linksById.get(id);
      if (!link) return;
      tocLinks.forEach((l) => l.classList.remove("toc-active"));
      link.classList.add("toc-active");
    }

    function getScrollOffset(): number {
      const paddingTop = 80; // ~5rem
      return paddingTop;
    }

    let cachedPositions: number[] = [];
    function recalcPositions() {
      const offset = getScrollOffset();
      cachedPositions = headingEls.map((h) => Math.max(0, h.offsetTop - offset));
    }

    function updateActiveFromScroll() {
      if (headingEls.length === 0) return;
      const y = window.scrollY;
      let idx = 0;
      for (let i = 0; i < cachedPositions.length; i++) {
        if (cachedPositions[i] <= y) idx = i;
        else break;
      }
      const currentId = headingEls[idx]?.id;
      setActive(currentId);
    }

    function updateFromHash() {
      const hash = decodeURIComponent(window.location.hash.replace(/^#/, ""));
      if (!hash) return;
      setActive(hash);
    }

    recalcPositions();
    updateFromHash();
    updateActiveFromScroll();

    const onScroll = () => {
      requestAnimationFrame(updateActiveFromScroll);
    };
    const onResize = () => {
      recalcPositions();
      updateActiveFromScroll();
    };
    const onHashChange = () => updateFromHash();

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onResize);
    window.addEventListener("hashchange", onHashChange);

    window.tocCleanup = () => {
      window.removeEventListener("scroll", onScroll);
      window.removeEventListener("resize", onResize);
      window.removeEventListener("hashchange", onHashChange);
    };
  }

  document.addEventListener("astro:page-load", initTableOfContents);

  if (document.readyState !== "loading") {
    initTableOfContents();
  }

  document.addEventListener("search-highlighting-complete", initTableOfContents);
</script>
